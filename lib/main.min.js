class Markov { chain = {}; #a; #b; threads; get seperator() { return this.#a } get length() { return this.#b } #c = []; debug = !1; constructor (a = "", b = 10, c = 8) { this.#a = a, this.#b = Math.max(1, b), this.threads = Math.min(navigator.hardwareConcurrency, Math.max(1, c)) } train(e, g = null) { let b = e.split(this.#a).filter(a => a), c = Math.floor(b.length / this.threads), h = performance.now(); this.debug && (console.log("[MARKOV] Starting training"), console.log(`[MARKOV] Threads: ${this.threads}, Batch Size: ${c}`)); let f = new Blob(["(", (function () { this.addEventListener("message", d => { let e = d.data.input, g = {}; for (let c = 0; c <= e.length - d.data.length; c++) { let f = 0, a = g, b = e[c + f]; for (; f !== d.data.length - 1;)a[b] || (a[b] = {}), a = a[b], b = e[c + ++f]; a[b] || (a[b] = 0), a[b]++ } postMessage({ chain: g }) }); close() }).toString(), ")()"], { type: "text/javascript" }); for (let a = 0; a < this.threads; a++) { let d = new Worker(URL.createObjectURL(f)); d.addEventListener("message", a => { let b = (c, d) => { for (let a in d) c[a] ? "number" == typeof c[a] ? c[a] += d[a] : b(c[a], d[a]) : c[a] = d[a] }; b(this.chain, a.data.chain), this.#c.splice(this.#c.indexOf(d), 1), this.debug && console.log(`[MARKOV] Training progress: ${(this.threads - this.#c.length) / this.threads * 100}%`), 0 === this.#c.length && (this.debug && console.log(`[MARKOV] Training complete in ${((performance.now() - h) / 1e3).toFixed(2)}s`), "function" == typeof g && g()) }, !1), d.postMessage({ input: b.slice(a * c, Math.min((a + 1) * c, b.length)), length: this.#b }), this.#c.push(d) } return this } predict(f, { start: c = "", alpha: g = 1 } = {}) { "string" == typeof c && (c = c.split(this.#a)); let a = c; for (; a.length < this.#b - 1;) { let d = this.chain; for (let l of a) d = d[l]; let h = Object.keys(d); a.push(h[Math.floor(Math.random() * h.length)]), f-- } try { for (let i = 0; i < f; i++) { let b = this.chain; for (let e = 1; e < this.#b; e++)b = b[a[a.length - this.#b + e]]; let j = 0; for (let m in b) j += b[m] * g; let n = Math.random() * j; for (let k in b) if ((n -= b[k] * g) <= 0) { a.push(k); break } } } catch (o) { console.warn(`[MARKOV] Chain is missing connection for: "${a.slice(a.length - this.#b).join('", "')}".`) } return a.join(this.#a) } clear() { return this.chain = {}, this } }