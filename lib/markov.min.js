class Markov { chain = {}; #a; #b; threads; get seperator() { return this.#a } get length() { return this.#b } #c = []; debug = !1; constructor (a = "", b = 10, c = 8) { this.#a = a, this.#b = Math.max(1, b), this.threads = Math.min(navigator.hardwareConcurrency, Math.max(1, c)) } train(e, f = null) { let b = e.split(this.#a).filter(a => a), c = Math.floor(b.length / this.threads), g = performance.now(); this.debug && (console.log("[MARKOV] Starting training"), console.log(`[MARKOV] Threads: ${this.threads}, Batch Size: ${c}`)); for (let a = 0; a < this.threads; a++) { let d = new Worker("https://kawyn.github.io/markov/lib/worker.min.js"); d.addEventListener("message", a => { let b = (c, d) => { for (let a in d) c[a] ? "number" == typeof c[a] ? c[a] += d[a] : b(c[a], d[a]) : c[a] = d[a] }; b(this.chain, a.data.chain), this.#c.splice(this.#c.indexOf(d), 1), this.debug && console.log(`[MARKOV] Training progress: ${(this.threads - this.#c.length) / this.threads * 100}%`), 0 === this.#c.length && (this.debug && console.log(`[MARKOV] Training complete in ${((performance.now() - g) / 1e3).toFixed(2)}s`), "function" == typeof f && f()) }, !1), d.postMessage({ input: b.slice(a * c, Math.min((a + 1) * c, b.length)), length: this.#b }), this.#c.push(d) } return this } predict(f, { start: c = "", alpha: g = 1 } = {}) { "string" == typeof c && (c = c.split(this.#a)); let a = c; for (; a.length < this.#b - 1;) { let d = this.chain; for (let l of a) d = d[l]; let h = Object.keys(d); a.push(h[Math.floor(Math.random() * h.length)]), f-- } for (let i = 0; i < f; i++) { let b = this.chain; for (let e = 1; e < this.#b; e++)b = b[a[a.length - this.#b + e]]; let j = 0; for (let m in b) j += b[m] * g; let n = Math.random() * j; for (let k in b) if ((n -= b[k] * g) <= 0) { a.push(k); break } } return a.join(this.#a) } clear() { return this.chain = {}, this } }